/*
 * Accounting API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@xero.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.xero.api;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.threeten.bp.Instant;
import org.threeten.bp.LocalDate;
import org.threeten.bp.LocalDateTime;
import org.threeten.bp.OffsetDateTime;
import org.threeten.bp.ZoneOffset;

public class StringUtil {
	private static final Pattern DATE_PATTERN = Pattern.compile("^/Date\\((\\d+)([+-]\\d+)?\\)/$");
	private static final Pattern DATE_PATTERN_NEG = Pattern.compile("^/Date\\(-(\\d+)([+-]\\d+)?\\)/$");

    /**
     * Check if the given array contains the given value (with case-insensitive
     * comparison).
     *
     * @param array
     *            The array
     * @param value
     *            The value to search
     * @return true if the array contains the value
     */
    public static boolean containsIgnoreCase(String[] array, String value) {
        for (String str : array) {
            if (value == null && str == null) {
                return true;
            }
            if (value != null && value.equalsIgnoreCase(str)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Join an array of strings with the given separator.
     * <p>
     * Note: This might be replaced by utility method from commons-lang or guava
     * someday if one of those libraries is added as dependency.
     * </p>
     *
     * @param array
     *            The array of strings
     * @param separator
     *            The separator
     * @return the resulting string
     */
    public static String join(String[] array, String separator) {
        int len = array.length;
        if (len == 0) {
            return "";
        }

        StringBuilder out = new StringBuilder();
        out.append(array[0]);
        for (int i = 1; i < len; i++) {
            out.append(separator).append(array[i]);
        }
        return out.toString();
    }

    public LocalDate convertStringToDate(String date)
            throws IOException {
        LocalDate formattedDate;
        Matcher m = DATE_PATTERN.matcher(date);
        Matcher matchNeg = DATE_PATTERN_NEG.matcher(date);
        if (m != null && m.matches()) {
            Long l = Long.parseLong(m.group(1));
            formattedDate = Instant.ofEpochMilli(l).atZone(ZoneOffset.UTC).toLocalDate();
        } else if (matchNeg != null && matchNeg.matches()) {
            Long l = Long.parseLong(matchNeg.group(1));
            formattedDate = Instant.ofEpochMilli(-l).atZone(ZoneOffset.UTC).toLocalDate();
        } else {
            throw new IllegalArgumentException("Wrong date format");
        }
        return formattedDate;
    }
    
    public OffsetDateTime convertStringToOffsetDateTime(String date)
            throws IOException {
        OffsetDateTime formattedDate;
        Matcher m = DATE_PATTERN.matcher(date);
        Matcher mNeg = DATE_PATTERN_NEG.matcher(date);
        if (m != null && m.matches()) {
            Long l = Long.parseLong(m.group(1));
            formattedDate = Instant.ofEpochMilli(l).atZone(ZoneOffset.UTC).toOffsetDateTime();
        } else if (mNeg != null && mNeg.matches()) {
            Long l = Long.parseLong(mNeg.group(1));
            formattedDate = Instant.ofEpochMilli(-l).atZone(ZoneOffset.UTC).toOffsetDateTime();
        } else {
            throw new IllegalArgumentException("Wrong date format");
        }
        return formattedDate;
    }

    public LocalDateTime convertStringToLocalDateTime(String date)
            throws IOException {
        LocalDateTime formattedDate;
        Matcher m = DATE_PATTERN.matcher(date);
        Matcher mNeg = DATE_PATTERN_NEG.matcher(date);
        if (m != null && m.matches()) {
            Long l = Long.parseLong(m.group(1));
            formattedDate = Instant.ofEpochMilli(l).atZone(ZoneOffset.UTC).toLocalDateTime();
        } else if (mNeg != null && mNeg.matches()) {
            Long l = Long.parseLong(mNeg.group(1));
            formattedDate = Instant.ofEpochMilli(-l).atZone(ZoneOffset.UTC).toLocalDateTime();
        } else {
            throw new IllegalArgumentException("Wrong date format");
        }
        return formattedDate;
    }
}
